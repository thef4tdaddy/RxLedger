#!/usr/bin/env bash

# Colors
GREEN="\033[0;32m"
RED="\033[0;31m"
YELLOW="\033[1;33m"
NC="\033[0m" # No Color

# Verify you're on main
current_branch=$(git rev-parse --abbrev-ref HEAD)
if [ "$current_branch" != "main" ]; then
  echo -e "${RED}âŒ You must be on 'main' to run this script. Current branch: '$current_branch'${NC}"
  exit 1
fi

# Check for uncommitted changes
if ! git diff-index --quiet HEAD --; then
  echo -e "${RED}âŒ You have uncommitted changes. Please commit or stash them before running this script.${NC}"
  exit 1
fi

# Check for local commits ahead of origin/main
if ! git diff --quiet origin/main..HEAD; then
  echo -e "${YELLOW}ğŸ” Detected local commits not pushed to origin/main${NC}"

  # Store commit hash range
  first_commit=$(git rev-list origin/main..HEAD | tail -1)
  commit_range="$first_commit^..HEAD"

  # Save commit messages
  last_msg=$(git log -1 --pretty=%B)

  echo -e "${YELLOW}âœ¨ Running Prettier and ESLint autofix...${NC}"
  npx prettier --write "src/**/*.{js,jsx,ts,tsx,json,css,md}"
  npx eslint --fix "src/**/*.{js,jsx,ts,tsx}"

  git add .
  git commit --amend --no-edit

  # Squash all local commits into one
  echo -e "${YELLOW}ğŸ”§ Squashing commits...${NC}"
  git reset --soft "$first_commit^"
  git commit -m "$last_msg"
  echo -e "${YELLOW}ğŸ’¾ Saving commit messages...${NC}"
  git log "$commit_range" --pretty=format:"%s" > /tmp/saved_commit_messages.txt

  # Create patch branch
  echo -e "${YELLOW}ğŸ“¦ Stashing local commits...${NC}"
  git checkout -b _temp_branch_with_commits

  # Move back to main and reset
  git checkout main
  git fetch origin
  git reset --hard origin/main

  # Ask for new branch name
  echo -e "${YELLOW}ğŸ”¹ Enter new branch name:${NC}"
  read branch

  if [ -z "$branch" ]; then
    echo -e "${RED}âŒ No branch name provided.${NC}"
    git branch -D _temp_branch_with_commits
    exit 1
  fi

  # Create the new branch and rebase commits onto it
  git checkout -b "$branch"
  git cherry-pick --allow-empty --strategy=recursive -X theirs "$first_commit^.._temp_branch_with_commits"

  # Push the new branch
  git push -u origin "$branch"

  # Switch back to main and hard reset
  git checkout main
  git fetch origin
  git reset --hard origin/main
  echo -e "${GREEN}âœ… Main hard reset to match origin/main.${NC}"

  # Switch to the new branch after pushing
  git checkout "$branch"

  echo -e "${GREEN}âœ… Branch '$branch' created with local commits rebased and pushed.${NC}"

  # Show saved commit messages before cleanup
  echo -e "${GREEN}ğŸ“ Saved commit messages:${NC}"
  cat /tmp/saved_commit_messages.txt

  # Clean up temp branch
  git branch -D _temp_branch_with_commits

else
  echo -e "${GREEN}âœ… No local commits to rebase.${NC}"

  # Ask for new branch name
  echo -e "${YELLOW}ğŸ”¹ Enter new branch name:${NC}"
  read branch

  if [ -z "$branch" ]; then
    echo -e "${RED}âŒ No branch name provided.${NC}"
    exit 1
  fi

  git checkout -b "$branch"
  git push -u origin "$branch"

  # Switch back to main and hard reset
  git checkout main
  git fetch origin
  git reset --hard origin/main
  echo -e "${GREEN}âœ… Main hard reset to match origin/main.${NC}"

  # Switch to the new branch after pushing
  git checkout "$branch"

  echo -e "${GREEN}âœ… Empty branch '$branch' created and pushed.${NC}"
fi
